<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>delta: Delta Language Specification</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">delta
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Delta Language Specification </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes the syntax and semantics of the Delta programming language.</p>
<h2>Introduction</h2>
<blockquote class="doxtable">
<p>Within C++, there is a much smaller and cleaner language struggling to get out.</p>
<p>— Bjarne Stroustrup </p>
</blockquote>
<p>Delta is a general-purpose systems programming language, intended as a replacement for C++ (and C) for large-scale performance-critical applications. The language should support interoperation with C++, and provide an automated C++-to-Delta code conversion tool to make gradual adoption as feasible as possible. In addition, the language should feel familiar and attractive to C++ programmers.</p>
<h3>Design principles</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Progressive_disclosure">Progressive disclosure</a> of complexity, i.e. it should be easy to write most of the code (the parts that aren't performance bottlenecks) to perform reasonably efficiently, and the language should provide full control to optimize the bottlenecks.</li>
<li>Code compiled in release mode must be as fast as possible on modern hardware.</li>
<li>Compilation in debug mode should be as fast as possible to speed up the edit-compile-run cycle during development.</li>
<li>Be able to call C++ (and vice versa) without having to write a C wrapper for everything.</li>
<li>Safe by default, but allow disabling safety checks (both individually and collectively) easily where necessary. E.g. array access bounds checking, integer overflow detection.</li>
<li>The language should be relatively simple, but most of the perceived simplicity should come from the aforementioned progressive disclosure principle. For simple things: "There should be one — and preferably only one
  — obvious way to do it."</li>
<li>Should support large-scale development, e.g. easy greppability of function/type/variable definitions.</li>
<li>Should be familiar and attractive to C++ and C developers.</li>
</ul>
<h2>Lexical structure</h2>
<h3>Keywords</h3>
<p>The following keywords are reserved and can't be used as identifiers. </p><pre class="fragment">break
case
cast
catch
class
const
continue
default
defer
deinit
do
else
enum
extern
fallthrough
false
for
func
if
import
in
init
inout
interface
let
move
mutable
mutating
null
private
public
return
static
struct
switch
this
throw
throws
true
try
typealias
uninitialized
var
while
_
</pre><p>The keywords <code>class</code> and <code>struct</code> can be used as variable names but not as a type names.</p>
<h3>Operators and delimiters</h3>
<p>Binary arithmetic operators: </p><pre class="fragment">+   -   *   /   **  %   &amp;   &amp;&amp;  |   ||  ^   &lt;&lt;  &gt;&gt;
+=  -=  *=  /=  **= %=  &amp;=  &amp;&amp;= |=  ||= ^=  &lt;&lt;= &gt;&gt;=
</pre><p>Binary comparison operators: </p><pre class="fragment">==  !=  &lt;   &gt;   &lt;=  &gt;=
</pre><p>Miscellaneous binary operators: </p><pre class="fragment">=   ..  ...
</pre><p>Unary prefix operators: </p><pre class="fragment">+   -   *   &amp;   !   ~
</pre><p>Unary postfix operators: </p><pre class="fragment">++  --  !
</pre><p>Delimiters: </p><pre class="fragment">(   )
[   ]
{   }
.   ,
:   ;
-&gt;
</pre><p>From the above set of operators, the following are overloadable by user code: <code>+</code> (both unary and binary), <code>-</code> (both unary and binary), <code>*</code>, <code>/</code>, <code>%</code>, <code>==</code>, <code>&lt;</code>.</p>
<h3>Comments</h3>
<p>Delta has two kinds of comments:</p>
<ul>
<li>Line comments that start with <code>//</code> and continue until the end of the line.</li>
<li>Block comments that start with <code>/*</code> and end with <code>*/</code>. Block comments can be nested.</li>
</ul>
<h3>Literals</h3>
<h4>Integer literal</h4>
<blockquote class="doxtable">
<p><em>binary-digit</em> → <code>0</code> | <code>1</code><br />
 <em>octal-digit</em> → <code>0</code> | <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code><br />
 <em>decimal-digit</em> → <code>0</code> | <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code> | <code>8</code> | <code>9</code><br />
 <em>nonzero-decimal-digit</em> → <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code> | <code>8</code> | <code>9</code><br />
 <em>lowercase-hex-digit</em> → <code>0</code> | <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code> | <code>8</code> | <code>9</code> | <code>a</code> | <code>b</code> | <code>c</code> | <code>d</code> | <code>e</code> | <code>f</code><br />
 <em>uppercase-hex-digit</em> → <code>0</code> | <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code> | <code>8</code> | <code>9</code> | <code>A</code> | <code>B</code> | <code>C</code> | <code>D</code> | <code>E</code> | <code>F</code><br />
</p>
<p><em>binary-integer-literal</em> → <code>0b</code> <em>binary-digit</em>+<br />
 <em>octal-integer-literal</em> → <code>0o</code> <em>octal-digit</em>+<br />
 <em>decimal-integer-literal</em> → <em>nonzero-decimal-digit</em> <em>decimal-digit</em>* | <code>0</code><br />
 <em>hex-integer-literal</em> → <code>0x</code> ( <em>lowercase-hex-digit</em>+ | <em>uppercase-hex-digit</em>+ )<br />
</p>
<p><em>integer-literal</em> → <em>binary-integer-literal</em> | <em>octal-integer-literal</em> | <em>decimal-integer-literal</em> | <em>hex-integer-literal</em><br />
 </p>
</blockquote>
<h4>Floating-point literal</h4>
<p>Floating-point literals have the form <code>[1-9][0-9]*\.[0-9]+</code> or <code>0\.[0-9]+</code>:</p>
<blockquote class="doxtable">
<p><em>floating-point-literal</em> → <em>nonzero-decimal-digit</em> <em>decimal-digit</em>* <code>.</code> <em>decimal-digit</em>+<br />
 <em>floating-point-literal</em> → <code>0</code> <code>.</code> <em>decimal-digit</em>+<br />
 </p>
</blockquote>
<h4>Boolean literal</h4>
<blockquote class="doxtable">
<p><em>boolean-literal</em> → <code>true</code> | <code>false</code><br />
 </p>
</blockquote>
<h4>Null literal</h4>
<blockquote class="doxtable">
<p><em>null-literal</em> → <code>null</code><br />
 </p>
</blockquote>
<h4>String literal</h4>
<blockquote class="doxtable">
<p><em>string-literal</em> → <code>"&lt;/tt&gt; (&lt;em&gt;character&lt;/em&gt; | &lt;em&gt;interpolated-expression&lt;/em&gt;)* &lt;tt&gt;"</code><br />
 <em>interpolated-expression</em> → <code>${</code> <em>expression</em> <code>}</code><br />
 </p>
</blockquote>
<h4>Array literal</h4>
<blockquote class="doxtable">
<p><em>array-literal</em> → <code>[</code> <em>elements</em> <code>]</code><br />
 </p>
</blockquote>
<p>where <em>elements</em> is a comma-separated list of zero or more expressions of the same type.</p>
<h4>Object literal</h4>
<blockquote class="doxtable">
<p><em>object-literal</em> → <code>(</code> <em>elements</em> <code>)</code><br />
 </p>
</blockquote>
<p>where <em>elements</em> is a comma-separated list of zero or more <em>object-literal-elements</em>:</p>
<blockquote class="doxtable">
<p><em>object-literal-element</em> → <em>identifier</em> <code>:</code> <em>expression</em><br />
 <em>object-literal-element</em> → <em>identifier</em><br />
 </p>
</blockquote>
<p>The second form is a shorthand for object-literal-elements of the form <code>x: x</code>.</p>
<p>Initializing a non-type-annotated variable with an object-literal causes the variable's type to be the tuple type corresponding to the object-literal.</p>
<h3>Identifiers</h3>
<blockquote class="doxtable">
<p><em>identifier-head</em> → upper- or lowercase letter <code>A</code> through <code>Z</code><br />
 <em>identifier-head</em> → <code>_</code><br />
 <em>identifier-head</em> → U+00A8 | U+00AA | U+00AD | U+00AF | U+00B2–U+00B5 | U+00B7–U+00BA<br />
 <em>identifier-head</em> → U+00BC–U+00BE | U+00C0–U+00D6 | U+00D8–U+00F6 | U+00F8–U+00FF<br />
 <em>identifier-head</em> → U+0100–U+02FF | U+0370–U+167F | U+1681–U+180D | U+180F–U+1DBF<br />
 <em>identifier-head</em> → U+1E00–U+1FFF<br />
 <em>identifier-head</em> → U+200B–U+200D | U+202A–U+202E | U+203F–U+2040 | U+2054 | U+2060–U+206F<br />
 <em>identifier-head</em> → U+2070–U+20CF | U+2100–U+218F | U+2460–U+24FF | U+2776–U+2793<br />
 <em>identifier-head</em> → U+2C00–U+2DFF | U+2E80–U+2FFF<br />
 <em>identifier-head</em> → U+3004–U+3007 | U+3021–U+302F | U+3031–U+303F | U+3040–U+D7FF<br />
 <em>identifier-head</em> → U+F900–U+FD3D | U+FD40–U+FDCF | U+FDF0–U+FE1F | U+FE30–U+FE44<br />
 <em>identifier-head</em> → U+FE47–U+FFFD<br />
 <em>identifier-head</em> → U+10000–U+1FFFD | U+20000–U+2FFFD | U+30000–U+3FFFD | U+40000–U+4FFFD<br />
 <em>identifier-head</em> → U+50000–U+5FFFD | U+60000–U+6FFFD | U+70000–U+7FFFD | U+80000–U+8FFFD<br />
 <em>identifier-head</em> → U+90000–U+9FFFD | U+A0000–U+AFFFD | U+B0000–U+BFFFD | U+C0000–U+CFFFD<br />
 <em>identifier-head</em> → U+D0000–U+DFFFD | U+E0000–U+EFFFD<br />
</p>
<p><em>identifier-character</em> → <code>0</code> | <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code> | <code>8</code> | <code>9</code><br />
 <em>identifier-character</em> → U+0300–U+036F | U+1DC0–U+1DFF | U+20D0–U+20FF | U+FE20–U+FE2F<br />
 <em>identifier-character</em> → <em>identifier-head­</em><br />
</p>
<p><em>identifier</em> → <em>identifier-head</em> <em>identifier-character</em>*<br />
 </p>
</blockquote>
<h2>Types</h2>
<h3>Integer types</h3>
<p>There are eight built-in integer types: <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, and their unsigned counterparts <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>. The standard library also provides <code>int</code> and <code>uint</code> which are type aliases for <code>int32</code> and <code>uint32</code>, respectively.</p>
<h3>Floating-point types</h3>
<p>There are three built-in floating-point types: <code>float32</code>, <code>float64</code>, and <code>float80</code>. The standard library also provides <code>float</code> and <code>double</code> which are type aliases for <code>float32</code> and <code>float64</code>, respectively.</p>
<h3>Reference types</h3>
<p>References are values that refer to other values. They can be reassigned to refer to another value, but they must always refer to some value. References referring to array types (see below) may be subscripted to access the array.</p>
<blockquote class="doxtable">
<p><em>reference-type</em> → <em>pointee-type</em> <code>&amp;</code><br />
 <em>reference-type</em> → <code>mutable</code> <em>pointee-type</em> <code>&amp;</code><br />
 <em>reference-type</em> → <code>mutable</code> <code>(</code> <em>pointee-type</em> <code>&amp;</code> <code>)</code><br />
 <em>reference-type</em> → <code>mutable</code> <code>(</code> <code>mutable</code> <em>pointee-type</em> <code>&amp;</code> <code>)</code><br />
 </p>
</blockquote>
<p>Prefixing the <em>pointee-type</em> with <code>mutable</code> makes the <em>pointee-type</em> mutable. Enclosing the <em>reference-type</em> in parentheses and prefixing the parentheses with <code>mutable</code> makes the <em>reference-type</em> itself mutable.</p>
<h3>Pointer types</h3>
<p>Pointers are like references, but may additionally store the value <code>null</code> to denote that they don't currently point to a valid value.</p>
<blockquote class="doxtable">
<p><em>pointer-type</em> → <em>pointee-type</em> <code>*</code><br />
 <em>pointer-type</em> → <code>mutable</code> <em>pointee-type</em> <code>*</code><br />
 <em>pointer-type</em> → <code>mutable</code> <code>(</code> <em>pointee-type</em> <code>*</code> <code>)</code><br />
 <em>pointer-type</em> → <code>mutable</code> <code>(</code> <code>mutable</code> <em>pointee-type</em> <code>*</code> <code>)</code><br />
 </p>
</blockquote>
<p>Prefixing the <em>pointee-type</em> with <code>mutable</code> makes the <em>pointee-type</em> mutable. Enclosing the <em>pointer-type</em> in parentheses and prefixing the parentheses with <code>mutable</code> makes the <em>pointer-type</em> itself mutable.</p>
<p>Pointer arithmetic can be performed by calling the <code>.offset(int64)</code> method on pointers. The method returns the offset pointer.</p>
<h3>Array types</h3>
<blockquote class="doxtable">
<p><em>sized-array-type</em> → <em>element-type</em> <code>[</code> <em>size</em> <code>]</code><br />
 <em>unsized-array-type</em> → <em>element-type</em> <code>[</code> <code>]</code><br />
 </p>
</blockquote>
<p><em>sized-array-types</em> are contiguous blocks of <em>size</em> elements of type <em>element-type</em>. <em>unsized-array-types</em> may only be used as return types and parameters types, and are implemented as pointer-and-size pairs under the hood, unless the compiler detects that the size is unused, in which case it will be optimized out.</p>
<h3>String type</h3>
<p>The type <code>string</code> holds sequences of Unicode characters.</p>
<h3>Composite types</h3>
<p>There are two kinds of composite types: classes and structs.</p>
<h4>Member variables</h4>
<p>Composite types contain a set of member variables. Each member variable may contain an associated getter and/or setter, that are called when the member variable is accessed or assigned to, respectively. The syntax of a member variable definition is as follows:</p>
<blockquote class="doxtable">
<p><em>let-or-var</em> → <code>let</code> | <code>var</code><br />
 <em>member-variable-declaration</em> → <em>let-or-var</em> <em>member-variable-name</em> <code>:</code> <em>type</em> <code>;</code><br />
 <em>member-variable-declaration</em> → <em>let-or-var</em> <em>member-variable-name</em> <code>:</code> <em>type</em> <code>{</code> <em>getter-setter-definitions</em> <code>}</code><br />
 <em>getter-setter-definitions</em> → <em>getter-definition</em> | <em>setter-definition</em> | <em>getter-definition</em> <em>setter-definition__<br />
 _getter-definition</em> → <code>get</code> <code>{</code> <em>getter-body</em> <code>}</code><br />
 <em>setter-definition</em> → <code>set</code> <code>{</code> <em>setter-body</em> <code>}</code><br />
 </p>
</blockquote>
<h4>Class types</h4>
<p>Types declared using the <code>class</code> keyword are <em>class types</em>, also called <em>reference types</em>. By default, they're allocated on the stack. When passed as functions arguments, they're passed by reference. When class types are returned from functions, they're moved if they're a local variable, or otherwise returned by reference.</p>
<p>Sometimes it's useful to pass classes by explicitly moving or copying them. This can be accomplished by using the <code>move</code> keyword, or constructing a new object by calling the copy constructor.</p>
<h4>Struct types</h4>
<p>Types declared using the <code>struct</code> keyword are <em>struct types</em>, also called <em>value types</em>. They're always allocated on the stack. When passed as function arguments and returned from functions, they're passed by copy.</p>
<p>Sometimes it's useful to explicitly pass structs by reference, for example in order to modify them inside the function, and have the changes affect the actual value outside the function. This can be accomplished by using the <code>inout</code> keyword.</p>
<h3>Interface types</h3>
<p>The <code>interface</code> keyword declares an interface, i.e. a set of requirements (member functions and properties). Types that fulfill the requirements of an interface <code>I</code> can be used as values for a variable of type <code>I</code>. This enables runtime polymorphism. Like classes and structs, interfaces may be generic.</p>
<h3>Optional type</h3>
<blockquote class="doxtable">
<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
<p>— C. A. R. Hoare </p>
</blockquote>
<p>An object of the optional type <code>T?</code> (where <code>T</code> is an arbitrary type) may contain a value of type <code>T</code> or the value <code>null</code>.</p>
<h3>Function types</h3>
<p>Function types are written out as follows:</p>
<blockquote class="doxtable">
<p><em>function-type</em> → <code>(</code> <em>parameter-type-list</em> <code>)</code> <code>-&gt;</code> <em>return-type</em><br />
 </p>
</blockquote>
<p>where <em>parameter-type-list</em> is a comma-separated list of parameter types.</p>
<h3>Tuple types</h3>
<blockquote class="doxtable">
<p><em>tuple-type</em> → <code>(</code><sub>opt</sub> <em>tuple-element-list</em> <code>)</code><sub>opt</sub><br />
 <em>tuple-element-list</em> → comma-separated list of one or more <em>tuple-elements</em><br />
 <em>tuple-element</em> → <em>name</em> <code>:</code> <em>type</em><br />
 </p>
</blockquote>
<p>Tuples behave like structs, but they're defined inline. Tuples are intended as a lightweight alternative for situations where defining a whole new struct feels overkill or inappropriate, e.g. returning multiple values from a function. The optional parentheses may be used for syntax disambiguation.</p>
<h4>Tuple unpacking</h4>
<p>The elements of a tuple value may be unpacked into individual variables as follows:</p>
<blockquote class="doxtable">
<p><em>tuple-unpack-statement</em> → <em>variable-list</em> <code>=</code> <em>tuple-expression</em> <code>;</code><br />
 </p>
</blockquote>
<p><em>variable-list</em> is a comma-separated list of one or more variable names. The variable names must match the element names of the <em>tuple-expression</em>, and be in the same order.</p>
<p>???</p>
<h3>Range types</h3>
<p>The standard library defines the following two generic structs to represent range types:</p>
<ul>
<li><code>Range&lt;T&gt;</code> for ranges with an exclusive upper bound</li>
<li><code>ClosedRange&lt;T&gt;</code> for ranges with an inclusive upper bound</li>
</ul>
<h2>Declarations</h2>
<h3>Variables</h3>
<p>Variable declarations introduce a new variable into the enclosing scope. The syntax is as follows:</p>
<blockquote class="doxtable">
<p><em>immutable-variable-declaration → <code>let</code> _variable-name</em> <code>:</code> <em>type</em> <code>;</code><br />
 <em>mutable-variable-declaration → <code>var</code> _variable-name</em> <code>:</code> <em>type</em> <code>;</code><br />
 <em>immutable-variable-definition</em> → <code>let</code> <em>variable-name</em> (<code>:</code> <em>type</em>)<sub>opt</sub> <code>=</code> <em>initializer</em> <code>;</code><br />
 <em>mutable-variable-definition</em> → <code>var</code> <em>variable-name</em> (<code>:</code> <em>type</em>)<sub>opt</sub> <code>=</code> <em>initializer</em> <code>;</code><br />
 </p>
</blockquote>
<p>In the first two forms, the variable is declared but not initialized. This allows delayed initialization, which causes the compiler to enforce that the variable is always initialized properly before its value is accessed.</p>
<p>If <em>type</em> is present, the variable has the specified type. The compiler ensures that the given <em>initializer</em> is compatible with this type. If no <em>type</em> is given, the compiler will infer the type of the variable from the <em>initializer</em>. The <em>initializer</em> is an expression that provides the initial value for the variable.</p>
<p>If <em>type</em> has been specified, <em>initializer</em> may also be the keyword <code>uninitialized</code>, in which case the variable is not initialized and all use-before-initialization warnings for the variable will be suppressed. Reading from an uninitialized variable causes undefined behavior.</p>
<h3>Functions</h3>
<p>A function can be defined with either of the following syntaxes:</p>
<blockquote class="doxtable">
<p><code>func</code> <em>function-name</em> <code>(</code> <em>parameter-list</em> <code>)</code> <code>{</code> <em>function-body</em> <code>}</code><br />
 <code>func</code> <em>function-name</em> <code>(</code> <em>parameter-list</em> <code>)</code> <code>-&gt;</code> <em>return-type</em> <code>{</code> <em>function-body</em> <code>}</code><br />
 </p>
</blockquote>
<p>The return type of the first version is <code>void</code>. The ___parameter-list___ is a comma-separated list of parameter declarations. A parameter declaration has one of the following syntaxes:</p>
<blockquote class="doxtable">
<p><em>parameter-name</em> <code>:</code> <em>parameter-type</em><br />
 </p>
</blockquote>
<p>___parameter-name___ is an identifier specifying the name of the parameter. A function cannot have multiple parameters with the same name.</p>
<p>___return-type___ defines what kind of values the function can return. This may be a tuple type to allow the function to return multiple values with a lightweight syntax.</p>
<p>Parameter and return types may not have a top-level <code>mutable</code> modifier.</p>
<h4>Member functions</h4>
<p>Member functions are just like normal functions, except that they receive an additional parameter (called the "receiver") on the left-hand-side of the function call, separated by a period:</p>
<blockquote class="doxtable">
<p><em>member-function-call</em> → <em>receiver</em> <code>.</code> <em>member-function-name</em> <code>(</code> <em>argument-list</em> <code>)</code><br />
 </p>
</blockquote>
<p>Member functions are defined with the same syntax as non-member functions, but are written inside a type declaration. That type declaration defines the member function's receiver type. Inside member functions, the receiver can be accessed with the keyword <code>this</code>.</p>
<h5>Initializers</h5>
<p>Initializers are a special kind of member functions that are used for initializing newly created objects.</p>
<blockquote class="doxtable">
<p><em>initializer-definition</em> → <code>init</code> <code>(</code> <em>parameter-list</em> <code>)</code> <code>{</code> <em>body</em> <code>}</code><br />
 </p>
</blockquote>
<p>Initializers can be invoked with the following syntax:</p>
<blockquote class="doxtable">
<p><em>initializer-call</em> → <em>receiver-type</em> <code>(</code> <em>argument-list</em> <code>)</code><br />
 </p>
</blockquote>
<p>The <em>initializer-call</em> expression returns a new instance of the specified <em>receiver-type</em> that has been initialized by calling the initializer function with a matching parameter list.</p>
<h5>Deinitializers</h5>
<p>Deinitializers are another special kind of member functions. They are automatically called on objects when they're destroyed. They can be used e.g. to deallocate resources allocated in an initializer. They are declared as follows:</p>
<blockquote class="doxtable">
<p><em>deinitializer-definition</em> → <code>deinit</code> <code>(</code> <code>)</code> <code>{</code> <em>body</em> <code>}</code><br />
 </p>
</blockquote>
<h4>Parameters</h4>
<p>Unlike C++ and C, Delta is not a copy-by-default language. When you declare a parameter to be of type <code>T</code>, the parameter is not automatically pass-by-value. Instead, whether <code>T</code> is a class or struct will determine how it's passed: classes are passed by reference (by default), while structs are passed by copy (by default).</p>
<p>To override the default behavior, the keywords <code>move</code> and <code>inout</code> may be used:</p>
<ul>
<li><code>move</code> can be applied to class parameters, and forces the argument to be a pass-by-value temporary, i.e. a freshly copied or moved value.</li>
<li><code>inout</code> can be applied to struct parameters, and causes any changes to the parameter to be reflected at the call site.</li>
</ul>
<h4>Private and public functions</h4>
<p>Both member functions and global functions may be declared private or public by prefixing the function definition with the keyword <code>private</code> or <code>public</code>. Private functions are only accessible from the file they're declared in. Public functions are accessible from anywhere, including other modules. Functions not marked private or public are <em>module-private</em>, i.e. only accessible within the module they're declared in.</p>
<h3>Classes</h3>
<p>Classes are defined as follows:</p>
<blockquote class="doxtable">
<p><em>class-definition</em> → <code>class</code> <em>class-name</em> <code>{</code> <em>member-list</em> <code>}</code><br />
 </p>
</blockquote>
<p><em>class-name</em> becomes the name of the class. <em>member-list</em> is a list of member variable declarations. Classes can be declared to implement interfaces by listing the interfaces after a <code>:</code> following the class name:</p>
<blockquote class="doxtable">
<p><code>class</code> <em>class-name</em> <code>:</code> <em>interface-list</em> <code>{</code> <em>member-list</em> <code>}</code><br />
 </p>
</blockquote>
<p>The <em>interface-list</em> is a comma-separated list of one or more interface names. The compiler will emit an error if the class doesn't actually implement the specified interfaces.</p>
<h4>Generic classes</h4>
<p>Generic classes can be declared as follows:</p>
<blockquote class="doxtable">
<p><code>class</code> <em>class-name</em> <code>&lt;</code> <em>generic-parameter-list</em> <code>&gt;</code> <code>{</code> <em>member-list</em> <code>}</code><br />
 </p>
</blockquote>
<p>where <em>generic-parameter-list</em> is a comma separated list of one or more generic parameters. A generic parameter is one of the following:</p>
<blockquote class="doxtable">
<p><em>generic-type-parameter</em> → <em>identifier</em><br />
 </p>
</blockquote>
<p>The identifier of a <em>generic-type-parameter</em> serves as a placeholder for types used to instantiate the generic class.</p>
<h3>Structs</h3>
<p>The syntax for declaring structs is exactly the same as for classes, except the keyword <code>class</code> is substituted with <code>struct</code>. Like classes, structs can be generic.</p>
<h3>Type aliases</h3>
<p>Unlike <code>typedef</code> in C++ and C, and <code>using</code> in C++, type aliases in Delta are strongly-typed, i.e. they define a whole new type. The new type behaves exactly as the target (aliased) type, except that it cannot be implicitly converted to or from that type. Explicit conversions on the other hand are allowed. This can be used to create type-safe abstractions.</p>
<blockquote class="doxtable">
<p><em>alias-declaration</em> → <code>class</code> <em>identifier</em> <code>=</code> <em>class-name</em> <code>;</code><br />
 <em>alias-declaration</em> → <code>struct</code> <em>identifier</em> <code>=</code> <em>struct-name</em> <code>;</code><br />
 <em>alias-declaration</em> → <code>interface</code> <em>identifier</em> <code>=</code> <em>interface-name</em> <code>;</code><br />
 </p>
</blockquote>
<p>Type aliases can also be generic:</p>
<blockquote class="doxtable">
<p><em>generic-alias-declaration</em> → <code>class</code> <em>identifier</em> <code>&lt;</code> <em>generic-parameter-list</em> <code>&gt;</code> <code>=</code> <em>class-name</em> <code>;</code><br />
 <em>generic-alias-declaration</em> → <code>struct</code> <em>identifier</em> <code>&lt;</code> <em>generic-parameter-list</em> <code>&gt;</code> <code>=</code> <em>struct-name</em> <code>;</code><br />
 <em>generic-alias-declaration</em> → <code>interface</code> <em>identifier</em> <code>&lt;</code> <em>generic-parameter-list</em> <code>&gt;</code> <code>=</code> <em>interface-name</em> <code>;</code><br />
 </p>
</blockquote>
<p>Generic parameters declared in the <em>generic-parameter-list</em> are available for use in the <em>class-name</em> / <em>struct-name</em> / <em>interface-name</em> part.</p>
<h2>Statements</h2>
<h3>Assignment statement</h3>
<blockquote class="doxtable">
<p><em>assignment-statement</em> → <em>lvalue-expression</em> <code>=</code> <em>expression</em> <code>;</code><br />
 <em>assignment-statement</em> → <code>_</code> <code>=</code> <em>expression</em> <code>;</code><br />
 </p>
</blockquote>
<p>Assignments in Delta don't return any value. This applies to compound assignments as well, including <code>++</code> and <code>--</code> (see below). Furthermore, this obsoletes the two different forms of <code>++</code> and <code>--</code>, so only the postfix versions are valid as syntactic sugar for <code>+= 1</code> and <code>-= 1</code>, respectively.</p>
<p>The assignment to <code>_</code>, called a <em>discarding assignment</em>, can be used to ignore the result of the expression, suppressing any compilation errors or warnings that would otherwise be emitted.</p>
<h3>Increment and decrement statements</h3>
<blockquote class="doxtable">
<p>increment-statement → <em>lvalue-expression</em> <code>++</code> <code>;</code><br />
 decrement-statement → <em>lvalue-expression</em> <code>--</code> <code>;</code><br />
 </p>
</blockquote>
<h3>Block</h3>
<blockquote class="doxtable">
<p><em>block</em> → <code>{</code> <em>statement</em>* <code>}</code><br />
 </p>
</blockquote>
<h3><code>if</code> statement</h3>
<blockquote class="doxtable">
<p><em>if-statement</em> → <code>if</code> <code>(</code> <em>expression</em> <code>)</code> <em>block</em> ( <code>else</code> <em>block</em> )<sub>opt</sub><br />
 <em>if-statement</em> → <code>if</code> <code>(</code> <em>expression</em> <code>)</code> <em>block</em> <code>else</code> <em>if-statement</em><br />
 </p>
</blockquote>
<h3><code>return</code> statement</h3>
<blockquote class="doxtable">
<p><em>return-statement</em> → <code>return</code> <em>return-value-list</em> <code>;</code><br />
 </p>
</blockquote>
<p><em>return-value-list</em> is a comma-separated list of zero or more return values.</p>
<h3><code>for</code> statement</h3>
<p>The <code>for</code> statement loop over a range. The syntax is as follows:</p>
<blockquote class="doxtable">
<p><em>for-statement</em> → <code>for</code> <code>(</code> <em>identifier</em> <code>in</code> <em>range-expression</em> <code>)</code> <em>block</em><br />
 </p>
</blockquote>
<h3><code>while</code> statement</h3>
<p>The <code>while</code> statement loops until a condition evaluates to <code>false</code>. The syntax is as follows:</p>
<blockquote class="doxtable">
<p><em>while-statement</em> → <code>while</code> <code>(</code> <em>condition</em> <code>)</code> <em>block</em><br />
 </p>
</blockquote>
<h3><code>switch</code> statement</h3>
<blockquote class="doxtable">
<p><em>switch-statement</em> → <code>switch</code> <code>(</code> <em>expression</em> <code>)</code> <code>{</code> <em>case</em>+ <code>}</code><br />
 <em>case</em> → <code>case</code> <em>expression</em> <code>:</code> <em>statement</em>+<br />
 <em>case</em> → <code>default</code> <code>:</code> <em>statement</em>+<br />
 </p>
</blockquote>
<p>In addition to integer types, the <code>switch</code> statement can be used to match strings.</p>
<p>The cases in a <code>switch</code> statement don't fall through by default. The fall-through behavior can be enabled for a individual cases with the <code>fallthrough</code> keyword.</p>
<p><code>switch</code> statements must be exhaustive if <em>expression</em> is of an enum type. This is enforced by the compiler.</p>
<h3><code>defer</code> statement</h3>
<p>The <code>defer</code> statement has the following syntax:</p>
<blockquote class="doxtable">
<p><em>defer-statement</em> → <code>defer</code> <em>block</em><br />
 </p>
</blockquote>
<p>The <em>block</em> will be executed when leaving the scope where the <em>defer-statement</em> is located. Multiple deferred blocks are executed in the reverse of the order they were declared in. Return statements are disallowed inside the defer block.</p>
<h2>Expressions</h2>
<h3>Unary expressions</h3>
<blockquote class="doxtable">
<p><em>prefix-unary-expression</em> → <em>operator</em> <em>operand</em><br />
 <em>postfix-unary-expression</em> → <em>operand</em> <em>operator</em><br />
 </p>
</blockquote>
<h4>Unwrap expression</h4>
<blockquote class="doxtable">
<p><em>unwrap-expression</em> → <em>operand</em> <code>!</code><br />
 </p>
</blockquote>
<p>The <em>unwrap expression</em> takes an expression of a pointer type as its operand and converts the pointer to a reference. If the pointer is null, a runtime error will be triggered by default. In unchecked mode the compiler may assume that the pointer expression is never null.</p>
<h3>Binary expression</h3>
<blockquote class="doxtable">
<p><em>binary-expression</em> → <em>left-hand-side</em> <em>binary-operator</em> <em>right-hand-side</em><br />
 </p>
</blockquote>
<h4>Integer arithmetic expressions</h4>
<p>Arithmetic operations on integers (both signed and unsigned) are checked for overflow by default. In unchecked builds, integer overflow causes undefined behavior (for both signed and unsigned operations).</p>
<h3>Conditional expression</h3>
<blockquote class="doxtable">
<p><em>conditional-expression</em> → <em>condition</em> <code>?</code> <em>then-expression</em> <code>:</code> <em>else-expression</em><br />
 </p>
</blockquote>
<h3>Member access expression</h3>
<blockquote class="doxtable">
<p><em>member-access-expression</em> → <em>expression</em> <code>.</code> <em>identifier</em><br />
 </p>
</blockquote>
<h3>Subscript expression</h3>
<blockquote class="doxtable">
<p><em>subscript-expression</em> → <em>expression</em> <code>[</code> <em>expression</em> <code>]</code><br />
 </p>
</blockquote>
<h3>Function call expression</h3>
<blockquote class="doxtable">
<p><em>call-expression</em> → <em>function-expression</em> <code>(</code> <em>argument-list</em> <code>)</code> <br />
 </p>
</blockquote>
<p><em>argument-list</em> is a comma-separated list of zero or more <em>argument-specifiers</em>:</p>
<blockquote class="doxtable">
<p><em>argument-specifier</em> → <em>unnamed-argument</em> | <em>named-argument</em><br />
 <em>unnamed-argument</em> → <em>expression</em><br />
 <em>named-argument</em> → <em>argument-name</em> <code>:</code> <em>expression</em><br />
 </p>
</blockquote>
<p><em>argument-name</em> is an identifier specifying the name of the parameter the argument <em>expression</em> is being assigned to.</p>
<h3>Range expression</h3>
<blockquote class="doxtable">
<p><em>exclusive-range-expression</em> → <em>lower-bound</em> <code>..</code> <em>upper-bound</em><br />
 <em>inclusive-range-expression</em> → <em>lower-bound</em> <code>...</code> <em>upper-bound</em><br />
 </p>
</blockquote>
<h3>Closure expression</h3>
<blockquote class="doxtable">
<p><em>closure-expression</em> → <code>(</code> <em>parameter-list</em> <code>)</code> <code>-&gt;</code> <em>expression</em><br />
 <em>closure-expression</em> → <code>(</code> <em>parameter-list</em> <code>)</code> <code>-&gt;</code> <em>block</em><br />
 <em>closure-expression</em> → <em>block</em><br />
 </p>
</blockquote>
<p>Specifying the type for parameters in a closure <em>parameter-list</em> is optional. Omitting the type (and the corresponding colon) causes the type for that parameter to be inferred from the context.</p>
<p>If the closure <em>parameter-list</em> only contains one parameter, the enclosing parentheses may be omitted.</p>
<h2>Error handling</h2>
<p>Functions that may throw errors are marked with the <code>throws</code> keyword, immediately after the <code>)</code> that terminates the parameter list. Other functions may never throw (the compiler enforces this), which helps generate more efficient code. Calling a throwing function requires the use of the <code>try</code> keyword:</p>
<blockquote class="doxtable">
<p><em>try-expression</em> → <code>try</code> <em>throwing-call-expression</em><br />
 </p>
</blockquote>
<p>This makes it clear which individual calls may throw and stop the execution in the enclosing function. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
